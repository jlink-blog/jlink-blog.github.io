---
layout: post
title: On-site TDD
date: 2014-08-01 16:28:37.000000000 +02:00
type: post
published: true
status: publish
categories: []
tags:
- tdd
- tdddecrypted
meta:
  _edit_last: '3482422'
  sharing_disabled: '1'
  switch_like_status: '1'
  geo_public: '0'
  _publicize_pending: '1'
  _oembed_21a99c2d4c7e0eb6bdb0cecb2de40d0e: "{{unknown}}"
  _oembed_bdeebe98747ff1db152c1e06d90c4608: "{{unknown}}"
  _oembed_6744780fb89c12dc6f56577262d3c066: "{{unknown}}"
  _oembed_09761fa5cd94dde561bf80afb500e2f9: "{{unknown}}"
  _oembed_d6ed32eb3d683143d811deff3750125e: "{{unknown}}"
  _oembed_88974eb7295cc33f61aa143aad4eaa1c: "{{unknown}}"
  _oembed_a92c005547b8734866ceeee158a44529: "{{unknown}}"
  _oembed_1da0bd0c09594dc28836efb834197430: "{{unknown}}"
  _oembed_1f9e9aec6c85dcc91bf5868a93552192: "{{unknown}}"
  _oembed_62d3f1414741aaf97911c09c9b7ebc76: "{{unknown}}"
  _oembed_f2524fc058bb3e7a2a1e79f6d2926015: "{{unknown}}"
  _oembed_e191a2f525cf6338cd2318f45954a342: "{{unknown}}"
  _oembed_0049703ebe6d1cebc0da6e90a6bc220b: "{{unknown}}"
  _oembed_5d39b40a5f16ab599cb3951d8a2c6a08: "{{unknown}}"
  _oembed_9f543f7cd0a1e747dec77297dab48d76: "{{unknown}}"
  _oembed_0e88b0cff4fc926b947e5a37e693806b: "{{unknown}}"
  _oembed_3f6195290ee0d185915128b8efdf3a00: "{{unknown}}"
  _oembed_022fc8d6bdd41ebe96f5691b2e2051c0: "{{unknown}}"
  _oembed_64899b3b97a8e17a5c062dc224501e2d: "{{unknown}}"
  _oembed_0e8a59073917d1846031bc8e6ec5b9a1: "{{unknown}}"
  _oembed_dd769e918601074bf73214b46db0a122: "{{unknown}}"
  _oembed_e50e41a73583f91498149ad8e51c2781: "{{unknown}}"
  _oembed_1082116a92ebf7f001183a2f911657f5: "{{unknown}}"
  _oembed_bc19226097f843d795881f9ac550fa41: "{{unknown}}"
  _oembed_2235c2bea03dadc100b6cea4bdc2887e: "{{unknown}}"
  _oembed_a9de802f4025931ca8013ec09ae44974: "{{unknown}}"
  _oembed_b00051c9ddef2a4f4d1aae3864e30513: "{{unknown}}"
  _oembed_405160a394d2349153aad76cc3aecb44: "{{unknown}}"
  _oembed_f7f5373d221b89ee874e660d30fcb4bf: "{{unknown}}"
  _oembed_07263b73cba08e2435b2c14ea57ab936: "{{unknown}}"
  _oembed_4e0343cd3befcf1a02b688247121057e: "{{unknown}}"
  _oembed_f89bfd57e2aa83251aadda8e2125feeb: "{{unknown}}"
  _oembed_662363340180415c786be5ff6e20c23d: "{{unknown}}"
  _oembed_e344355d2ace691d73608e7479efb6d8: "{{unknown}}"
  _oembed_90c2f98cdba8f227fe23692eab46e6b0: "{{unknown}}"
  _oembed_e46def588eb21204521fb69e9de6fc08: "{{unknown}}"
  _oembed_6d2584aa4de982a7735e13add9a1952b: "{{unknown}}"
  _oembed_0512449d78cf6996c29d80e73087f9f8: "{{unknown}}"
  _oembed_a49baa60c16aed07a865cc6f596067b6: "{{unknown}}"
  _oembed_3b2cd930285087bc034f3fad615325c7: "{{unknown}}"
  _oembed_a5a7c207a6b9e76e3973575a4f6ce342: "{{unknown}}"
  _oembed_3eb9e1acde995e11652d8a06bd3cd415: "{{unknown}}"
  _oembed_19cef75d504954037bb02b1c3206fe6e: "{{unknown}}"
  _oembed_0508daeb862e9259f3b3ee485eec26cf: "{{unknown}}"
  _oembed_abc7d826fe6bb0bde02f91f370bdcfa1: "{{unknown}}"
  _oembed_a53ea71aaf1aeb828269e473e6bbbe51: "{{unknown}}"
  _oembed_4ddfe8c9841009d6928b17b2c519de15: "{{unknown}}"
  _oembed_4e5c1f411985c54f2828b9710370e44a: "{{unknown}}"
  _oembed_1a6c285eb5d08d43250367a4335ab96b: "{{unknown}}"
  _oembed_0771a9ba46bbf166ca43b7f05af61c23: "{{unknown}}"
  _oembed_95f34f871a670e41125e18ffe9b58ed8: "{{unknown}}"
  _oembed_35bc038bdfe542e68662f19310869fef: "{{unknown}}"
  _oembed_a020e86a8e2a1c9d2db122b200988cd6: "{{unknown}}"
  _oembed_310ab74d5e260362e736534a99ce9d95: "{{unknown}}"
  _oembed_1726a8bb5e9d8effd91567a48b87548c: "{{unknown}}"
  _oembed_6f05485fc89576e3ff63f8ea982badf2: "{{unknown}}"
  _oembed_ef54c114144e12ca789c4689fa40ff0b: "{{unknown}}"
  _oembed_ac7b9866d52ef5dfc101190c0cc5cb94: "{{unknown}}"
  _oembed_870eb9fdfde039de32b7c92347ca240d: "{{unknown}}"
  _oembed_3ef24d94a01f0a1de828028a87830ca8: "{{unknown}}"
  _oembed_83c76a48e9dc1ee6d672cac1f997d777: "{{unknown}}"
  _oembed_a7c02a0ac7fa44881576b2bbfe2d9a7f: "{{unknown}}"
  _oembed_dbbb549374ddc66d199234863c285398: "{{unknown}}"
  _oembed_15fc9348b2342babcfe30aca3eb1b5ff: "{{unknown}}"
  _oembed_119ec88ac63a72613060c0c8dee71bbf: "{{unknown}}"
  _oembed_a8da402c60da207bbc393b71989b2597: "{{unknown}}"
  _oembed_2273f437a9b4b163e5232172ce5d17ab: "{{unknown}}"
  _oembed_ed05fa555df02eccc955ddeeccfec89f: "{{unknown}}"
  _oembed_68d5f0bcf3c38d6da75c05149a4b5be9: "{{unknown}}"
  _oembed_13e969328cc641d1e154a33122478060: "{{unknown}}"
  _oembed_5a8d9000a5c13a9b78f9d5517b17eba3: "{{unknown}}"
  _oembed_ede7afde1afe6425d3fa7c1024986f43: "{{unknown}}"
  _oembed_f57660dde00f2050f35efe83c6a9318f: "{{unknown}}"
  _oembed_a0af27fe5e0ab6847f251fe9429e320f: "{{unknown}}"
  _oembed_d4b8b5c43a989bd710fe4313ca5907bb: "{{unknown}}"
  _oembed_66902c4b0088c916421963cdaaf46c03: "{{unknown}}"
  _oembed_0ff1067b254d65cdf08b15d5a22efd08: "{{unknown}}"
  _oembed_045ccbe21151eead171a7f3868456c5b: "{{unknown}}"
author:
  login: johanneslink
  email: jl@johanneslink.net
  display_name: johanneslink
  first_name: Johannes
  last_name: Link
---
<p>One of the recurring questions in TDD workshops is "How do I test private methods?“. My usual answer is worded along the following lines: "You don’t. Any private method should be tested through the public interface. If you think the private method is complex enough for deserving its own test(s), extract it to a public place and test it there.“ I still think this is the best general answer I can give, however, I recently discovered a set of situations that I handle differently.</p>
<p>Imagine yourself trying to implement some non-trivial solution to a problem. By "non-trivial“ I mean that the necessary algorithm is complicated enough so that you cannot oversee all intermediate steps and decision points in your mind alone.&nbsp; You’re tackling the problem step by step — pardon-me — test by test. At some point, there will be one test that forces you to implement at least part of the algorithm. The tests you created will eventually be sufficient to cover the logic, but they are not fine-grained enough to let you grow the solution in tiny, controllable steps.</p>
<p>Enter <em>On-site TDD</em>. This technique runs a few TDD cycles "on-site“ meaning "directly inside the production code“. The goal is to enable finer-grained TDD without the overhead of having to (temporarily) extract an implementation detail. Let’s demonstrate the technique with an example: Our task is to encrypt a text using <a href="http://en.wikipedia.org/wiki/Transposition_cipher#Columnar_transposition">columnar transposition</a>: You take a String <em>text</em> and an Integer <em>key</em>, split the text into lines of length <em>key</em> and then assemble the text by columns — top-down and left to right. Here is the encryption table for "<code>the battle will start at daybreak</code>“ with key 7. Ignoring all spaces the resulting cipher text is "<code>tltaheayewrbbitralaetltatsdk</code>“:</p>
<p><a href="https://johanneslink.files.wordpress.com/2014/08/columnartransposition.jpg"><img src="{{ site.baseurl }}/assets/columnartransposition.jpg?w=300" alt="columnarTransposition" width="300" height="168" class="alignnone size-medium wp-image-451" /></a></p>
<p>In order to reduce the usual testing framework noise I’ll go with a simple Groovy script for both test code and production code. I’ll leave it to the astute reader to imagine test classes and production classes.</p>
<p>We start with the trivial case:</p>
<pre>
assert encrypt('ab', 2) == 'ab'

def encrypt(text, key) {
  text
}
</pre>
<p>And proceed to an example that requires to really work with the input text:</p>
<pre>
assert encrypt('abcdef', 3) == 'adbecf'
</pre>
<p>which can trivially be fulfilled like this:</p>
<pre>
def encrypt(text, key) {
<strong>  if (text == 'abcdef' &amp;&amp; key == 3) {
    return 'adbecf'
  }
</strong>  text
}
</pre>
<p>At this point we have several options:</p>
<ul>
<li>Adding another example and then try to come up with the implementation all at once. This is called <em>triangulation</em>.</li>
<li>Trying to write a real implementation now and tweak it till the tests pass.</li>
<li>Evolving the algorithm and tests step by step -- inside the production code. This is what I will show here...</li>
</ul>
<p>We focus on the non-trivial branch and specify the first piece on our way to a working algorithm, which is splitting the text into individual characters:</p>
<pre>
def encrypt(text, key) {
  if (text == ‚abcdef' &amp;&amp; key == 3) {
<strong>    def chars
    assert chars == ['a', 'b', 'c', 'd', 'e', 'f']
</strong>    return 'adbecf'
  }
  text
}
</pre>
<p>Now our tests will fail, but we can easily fix this:</p>
<pre>
def encrypt(text, key) {
  if (text == 'abcdef' &amp;&amp; key == 3) {
    def chars = <strong>text.toList()</strong>
    assert chars == ['a', 'b', 'c', 'd', 'e', 'f']
    return 'adbecf'
  }
  text
}
</pre>
<p>Next, we add an assertion for splitting the chars into lines of length 3:</p>
<pre>
def encrypt(text, key) {
  if (text == 'abcdef' &amp;&amp; key == 3) {
    def chars = text.toList()
    assert chars == ['a', 'b', 'c', 'd', 'e', 'f']
<strong>    def lines
    assert lines == [['a', 'b', 'c'], ['d', 'e', 'f']]
</strong>    return 'adbecf'
  }
  text
}
</pre>
<p>And again, fixing the broken test is just a matter of looking up the correct method in Groovy’s Development Kit:</p>
<pre>
def encrypt(text, key) {
  if (text == 'abcdef' &amp;&amp; key == 3) {
    def chars = text.toList()
    assert chars == ['a', 'b', 'c', 'd', 'e', 'f']
    def lines = <strong>chars.collate(key)</strong>
    assert lines == [['a', 'b', 'c'], ['d', 'e', 'f']]
    return 'adbecf'
  }
  text
}
</pre>
<p>Let’s speed up a bit. Here come assertion and implementation for converting the lines to columns:</p>
<pre>
def encrypt(text, key) {
  if (text == 'abcdef' &amp;&amp; key == 3) {
    def chars = text.toList()
    assert chars == ['a', 'b', 'c', 'd', 'e', 'f']
    def lines = chars.collate(key)
    assert lines == [['a', 'b', 'c'], ['d', 'e', 'f']]
<strong>    def columns = lines.transpose()
    assert columns == [['a', 'd'], ['b', 'e'], ['c', 'f']]
</strong>    return 'adbecf'
  }
  text
}
</pre>
<p>The last but one step is flattening the columns:</p>
<pre>
def encrypt(text, key) {
  if (text == 'abcdef' &amp;&amp; key == 3) {
    def chars = text.toList()
    assert chars == ['a', 'b', 'c', 'd', 'e', 'f']
    def lines = chars.collate(key)
    assert lines == [['a', 'b', 'c'], ['d', 'e', 'f']]
    def columns = lines.transpose()
    assert columns == [['a', 'd'], ['b', 'e'], ['c', 'f']]
<strong>    def cryptedChars = columns.flatten()
    assert cryptedChars == ['a', 'd', 'b', 'e', 'c', 'f']
</strong>    return 'adbecf'
  }
  text
}
</pre>
<p>What remains is assembling the letters into a string:</p>
<pre>
def encrypt(text, key) {
  if (text == 'abcdef' &amp;&amp; key == 3) {
    def chars = text.toList()
    assert chars == ['a', 'b', 'c', 'd', 'e', 'f']
    def lines = chars.collate(key)
    assert lines == [['a', 'b', 'c'], ['d', 'e', 'f']]
    def columns = lines.transpose()
    assert columns == [['a', 'd'], ['b', 'e'], ['c', 'f']]
    def cryptedChars = columns.flatten()
    assert cryptedChars == ['a', 'd', 'b', 'e', 'c', 'f']
<strong>    def result = cryptedChars.join('')
    assert result == 'adbecf'
</strong>    return result
  }
  text
}
</pre>
<p>Now we can get rid of asserts and the special-case branch:</p>
<pre>
assert encrypt('ab', 2) == 'ab'
assert encrypt('abcdef', 3) == 'adbecf'

def encrypt(text, key) {
  def chars = text.toList()
  def lines = chars.collate(key)
  def columns = lines.transpose()
  def encryptedChars = columns.flatten()
  def result = encryptedChars.join('')
  return result
}
</pre>
<p>Et voilà, we arrived at a working algorithm in tiny steps; much tinier than would have been possible by sticking to assertions within the test class only. Of course, you should choose the step size according to your knowledge of language and domain. When in doubt, take a smaller step to stay in full control. </p>
<p>Most of the times I am happy with deleting the assertions now that they've fulfilled their duty. When I feel they should stick around after all, I will make real tests out of them by extracting the logic into a class of its own and moving the assertions to a test class - an existing or a new one, depending on where I extracted the code to.</p>
<p>One precondition for doing <em>On-site TDD</em> is the ability to write assertions - or something to the same effect - inside your production code without thereby creating a dependency on the test framework. If you cannot do that, there is another way of achieving something similar: First, move the parts of the production code you want to evolve over to your test class. Second, go about implementing your solution in the way I’ve demonstrated above. Last, move the code back to the production class. This is - by the way - what you’re supposed to do when practicing <a href="http://gojko.net/2009/08/02/tdd-as-if-you-meant-it-revisited/">"TDD as if you meant it“</a>.</p>
<p>As always, feedback and criticism is more than welcome!</p>
<h2>Update 1: REPL</h2>
<p>As some of the commenters on twitter mentioned: When you're lucky enough to use a language with a decent REPL, most (if not all) of the On-site TDD steps can be done there. When using a REPL with inline evaluations (e.g. light table) you might even forgo the assertions completely since you do see the values of the temp vars anyway.</p>
<h2>Update 2: Outside-In</h2>
<p>One of the commenters remarked that On-site TDD looks like mostly useful for inside-out (or bottom-up) TDD. So far I have been using it exclusively in inside-out situations. Trying to imagine useful outside-in scenarios is not straightforward - at least not to me. As far as my experiments went, using a dependency was never complicated enough that On-site TDD seemed necessary. But hey, if YOU come up with a good example, PLEASE let me know.</p>
